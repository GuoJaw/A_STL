#include<iostream>
using namespace std;

//不同的迭代器类：my_iterator1  my_iterator2  my_iterator3
template <class T>
class my_iterator1{  //迭代器1
public:
	typedef T value_type;
};

template <class T>
class my_iterator2{  //迭代器2
public:
	typedef T value_type;
};

template <class T>
class my_iterator3{  //迭代器3
public:
	typedef T value_type;
};

/*
	typename的作用： T 是一个模板类型参数，在它被编译器具现化之前，
	编译器对 T 一无所知，换句话说：编译器此时并不知道T::value_type是什么，
	关键词typename的用意在于告诉编译器这是一个数据类型，这样才能顺利通过编译
*/
template <class T>
class MyIter_traits{ //萃取机
public:
	typedef typename T::value_type value_type; //告诉编译器T::value_type是类型
};

template<class T>
void advance(T& iter){
	cout << typeid(iter).name() << endl;
}

int main(){
	my_iterator1<int> iter1;
	advance(iter1); //class my_iterator1<int>

	my_iterator2<int> iter2;
	advance(iter2); //class my_iterator2<int>

	my_iterator3<int> iter3;
	advance(iter3); //class my_iterator3<int>
}

	
		
